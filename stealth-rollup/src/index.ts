import { ActionSchema, FIFOStrategy, MicroRollup } from "@stackr/stackr-js";
import bodyParser from "body-parser";
import express, { Request, Response } from "express";
import { stackrConfig } from "../stackr.config";
import { AnnouncementRollup, announcementSTF } from "./state";
import { StateMachine } from "@stackr/stackr-js/execution";

// this file is generated by the deployment script
import * as genesisState from "../genesis-state.json";
import { ethers } from "ethers";

const rollup = async () => {
  const counterFsm = new StateMachine({
    state: new AnnouncementRollup({
      announcements: [
        {
          stealthAddress: "0x084c53dad73b23f7d709fdcc2edbe5caa44bccce",
          ephemeralPublicKey:
            "0x0391e14240e98bc771f00b5ad49f3f7ec92fd498e43f04708fd61f02fddc0931f2",
          viewTag: 33,
        },
      ],
      registers: [
        {
          publicAddress: "0x084c53dad73b23f7d709fdcc2edbe5caa44bccce",
          stelathMetaAddress:
            "0x02f868433a12a9d57e355176a00ee6b5c80ed1fe2c939d81062e0251081994f039022290fba566a42824f283e54582fc4fefb0767f04551c748aa8bd8b66bef677cf",
          schemeId: 0,
        },
      ],
    }),
    stf: announcementSTF,
  });

  const actionSchemaType = {
    type: "String",
    stealthAddress: "Address",
    ephemeralPublicKey: "Bytes",
    viewTag: "Uint",
    publicAddress: "Address",
    stelathMetaAddress: "Bytes",
    schemeId: "Uint",
  };

  const actionInput = new ActionSchema("update-announcement", actionSchemaType);

  const buildStrategy = new FIFOStrategy();

  const { state, actions, events } = await MicroRollup({
    config: stackrConfig,
    useState: counterFsm,
    useAction: actionInput,
    useBuilder: { strategy: buildStrategy, autorun: true },
    useSyncer: { autorun: true },
  });

  // events.action.onEvent(ActionEvents.SUBMIT_ACTION, (action) => {
  //   console.log("action submitted", action);
  // });

  // events.batcher.onEvent(BatcherEvents.BATCH_ACTION, (batch) => {
  //   console.log("action batched", batch);
  // });

  // events.builder.onEvent(BuilderEvents.ORDER_BATCH, (batch) => {
  //   console.log("action batch ordered", batch);
  // });

  return { state, actions };
};

const app = express();
app.use(bodyParser.json());
const { actions, state } = await rollup();
var cors = require("cors");
app.use(cors());

app.get("/announcements", (req: Request, res: Response) => {
  res.send({ currentAnnouncement: state.get().state.getState().announcements });
});

app.get("/registers", (req: Request, res: Response) => {
  res.send({ currentRegistry: state.get().state.getState().registers });
});

const actionSchemaType = {
  type: "String",
  stealthAddress: "Address",
  ephemeralPublicKey: "Bytes",
  viewTag: "Uint",
  publicAddress: "Address",
  stelathMetaAddress: "Bytes",
  schemeId: "Uint",
};

const actionInput = new ActionSchema("update-announcement", actionSchemaType);

app.post("/update", async (req: Request, res: Response) => {
  const schema = actions.getSchema("update-announcement");

  if (!schema) {
    res.status(400).send({ message: "error" });
    return;
  }

  try {
    const wallet = ethers.Wallet.createRandom();

    const sign = await wallet.signTypedData(
      stackrConfig.domain,
      actionInput.EIP712TypedData.types,
      req.body
    );

    // console.log(actionInput.EIP712TypedData.types);
    console.log(req.body);
    const payload = {
      msgSender: wallet.address,
      signature: sign,
      payload: req.body,
    };

    const newAction = await schema.newAction(payload);
    const ack = await actions.submit(newAction);
    res.status(201).send({ ack });
  } catch (e: any) {
    res.status(400).send({ error: e.message });
  }
});

app.listen(8080, () => {
  console.log("listening on port 8000");
});

// actionEventsEmitter.on(ActionEvents.SUBMIT_ACTION, (data) => {
//   console.log("submit_action - Event triggered : ", data.payload);
// });

// executorEventsEmitter.on(ExecutorEvents.EXECUTE_SINGLE, (data) => {
//   console.log("execute_single - Event triggered : ", data);
// });
